#labels Featured
== Simple Example ==
This example is trivial but shows the basics for constructing a simple mock of an interface and stubbing its only virtual function.
{{{
#include <UnitTest++.h>
#include <mockitopp/MockObject.hpp>

// some interface
struct Foo
{
   virtual void bar() = 0;
};

// a simple test case
using mockitopp::MockObject;
TEST(MyTestCase)
{
   MockObject<Foo> mock;
   mock.stub(&Foo::bar);
   Foo& fooImpl = mock.getMock();
   fooImpl.bar();
}
}}}

== Returnable Behavior ==
This example shows how you can define simple returnable behavior for an object.  You will notice that we chained a bunch of arguments and their return values together in a nice readable format. We then have our associated UnitTest++ {{{CHECK}}} macros verify the expected behavior. As you can see we make a call to {{{adderImpl.add(4, 5)}}}, but we didn't define any behavior for it. What happens in this case is the stub implementation will try to return the default behavior for function's signature.  This means for POD (i.e. {{{int}}}, {{{bool}}}, etc.) it will return 0, false, 0.0, etc.  For objects it will try to return the object using the default constructor (i.e. {{{std::string()}}}, {{{std::vector()}}}, etc).  For pointers it will return {{{NULL}}}. For reference types it will do a very dangerous cast from a pointer to a primitive to a reference of the return type (which may or may not be desired, SO BE CAREFUL).
{{{
#include <UnitTest++.h>
#include <mockitopp/MockObject.hpp>

// some interface
struct Adder
{
   virtual int add(int a, int b) = 0;
};

// test case
using mockitopp::MockObject;
TEST(MyTestCase)
{
   MockObject<Adder> mock;
   mock.stub(&Adder::add).arguments(0, 0).returns(0)
                         .arguments(1, 1).returns(2)
                         .arguments(2, 2).returns(5); // most certainly 2 + 2 = 5!
   Adder& adderImpl = mock.getMock();

   CHECK(adderImpl.add(0, 0) == 0);
   CHECK(adderImpl.add(1, 1) == 2);
   CHECK(adderImpl.add(2, 2) == 5);
   // What does 4 + 5 return?
   // We didn't define any behavior!!!
   CHECK(adderImpl.add(4, 5) == 0);
}
}}}

== Throwable Behavior ==
This example shows how you can define simple throwable behavior for an object.  Similarly to the returnable action behavior you can instead decide to use {{{throws(...)}}} to define a throwable action. AS you may ahve noticed you can chain together multiple throwable and returnable actions.  This is useful for cases where your mock object is only expected to handle certain argument types.
{{{
#include <UnitTest++.h>
#include <mockitopp/MockObject.hpp>

// some interface
struct Adder
{
   virtual int add(int a, int b) = 0;
};

// test case
using mockitopp::MockObject;
TEST(MyTestCase)
{
   MockObject<Adder> mock;
   mock.stub(&Adder::add).arguments(0, 0).returns(0)
                         .arguments(1, 1).returns(2)
                         .arguments(2, 2).throws(std::string("I don't support this!")); // Don't believe me? I dare you to try it!
   Adder& adderImpl = mock.getMock();

   CHECK(adderImpl.add(0, 0) == 0);
   CHECK(adderImpl.add(1, 1) == 2);
   try
      { int result = adderImpl.add(2, 2); }
   catch(std::string& s)
      { std::cout << s << std::endl; }
}
}}}

== Void Functions ==
You can stub functions that return {{{void}}} similarly to the way it is done for functions with return values. The different is that the {{{returns}}} method takes no arguments, while the {{{throws}}} method still operates as expected.

What happens when you don't stub behavior for a given input? In this case it operates as if you stubbed the argument using the {{{returns}}} method.
{{{
#include <UnitTest++.h>
#include <mockitopp/MockObject.hpp>

// some interface
struct Foo
{
   virtual void bar(int x) = 0;
};

// test case
using mockitopp::MockObject;
TEST(MyTestCase)
{
   MockObject<Foo> mock;
   mock.stub(&Foo::bar).arguments(0).returns()
                       .arguments(1).returns()
                       .arguments(2).throws(std::string("Invalid argument!"));
   Foo& foo = mock.getMock();

   try
   {
      foo.bar(0); // returns cause we stubbed it
      foo.bar(1); // returns cause we stubbed it
      foo.bar(3); // returns even though we didn't stub it for this argument
      foo.bar(2); // throws stubbed exception
   }
   catch(std::string& s)
      { std::cout << s << std::endl; }
}
}}}

== Iterator-Style ==
You can stub arguments to return different values on consecutive calls.  This is useful for modeling iterator like behavior for a given argument list.  It even works with a fucntion that takes no arguments.  The configuration is similar to the previous uses except you chain together consecutive calls to the {{{returns}}} and {{{throws}}} methods from a single call to the {{{arguments}}} method.  Also, the last stubbed {{{returns}}} or {{{throws}}} becomes the default behavior on consecutive calls after the the last element is hit.
{{{
#include <UnitTest++.h>
#include <mockitopp/MockObject.hpp>

// some interface
struct Enumeration
{
   virtual int next() = 0;
};

// test case
using mockitopp::MockObject;
TEST(MyTestCase)
{
   MockObject<Enumeration> mock;
   mock.stub(&Enumeration::next).arguments().returns(0)
                                            .returns(1)
                                            .throws(std::string("Invalid argument!"))
                                            .returns(2)
                                            .returns(3);
   Enumeration& e = mock.getMock();

   CHECK(0 == e.next()); // should return 0
   CHECK(1 == e.next()); // should return 1
   try
      { CHECK(1 == e.next()); /*should throw an exception*/ }
   catch(...)
      { /*ignore*/ }
   CHECK(2 == e.next()); // should return 2
   CHECK(3 == e.next()); // should return 3
   CHECK(3 == e.next()); // remaining consecutive calls return the last stubbed value
}
}}}