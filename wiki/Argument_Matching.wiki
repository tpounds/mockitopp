#labels Featured
== Argument Matching ==
Usually, test cases are required to cover a large permutation of user inputs. This can be troublesome in cases where the system under test has several underlying dependencies. Usually, when using a mock framework to provide the dependencies for the system under test, each dependency will have to stubbed with 1:1 mappings of the user inputs. Overtime this makes test cases quite brittle and becomes a maintenance liability. To help reduce this overhead generic argument matchers are available ({{{<mockitopp/matchers>}}}) to use when stubbing method invocations.  There are also several optional argument matchers available ({{{<mockitopp/matchers/optional>}}}) that support popular frameworks such as *[http://code.google.com/p/hamcrest/ Hamcrest]* and *[http://www.boost.org/doc/libs/1_36_0/libs/regex/doc/html/index.html TR1 <regex>]*.

=== Built-in ===
{{{
#include <gtest/gtest.h>
#include <mockitopp/mockitopp.hpp>

using mockitopp::matcher::eq;
using mockitopp::matcher::not_;
using mockitopp::matcher::null;

struct interface
{
   virtual bool func1(int*) = 0;
   virtual bool func2(const std::string&) = 0;
};

TEST(test, built_in)
{
   mockitopp::mock_object<interface> mock;
   mock(&interface::func1).when(null<int*>()).thenReturn(true);
   mock(&interface::func2).when(not_(eq(std::string("foo")))).thenReturn(true);
   interface& obj = mock.getInstance();

   ASSERT_TRUE(obj.func1(0));
   ASSERT_TRUE(obj.func2("hello world!"));
   ASSERT_TRUE(obj.func2("bar"));
   ASSERT_THROW(obj.func1(new int), mockitopp::detail::IncompleteImplementationException);
   ASSERT_THROW(obj.func2("foo"), mockitopp::detail::IncompleteImplementationException);
}
}}}

=== [http://code.google.com/p/hamcrest/ Hamcrest] ===
{{{
#include <gtest/gtest.h>
#include <matchers/hc_any_of.h>
#include <matchers/hc_equal_to.h>

using hamcrest::any_of;
using hamcrest::equal_to;
using mockitopp::matcher::hc;

struct interface
{
   virtual bool func(const char*) = 0;
};

TEST(test, hamcrest)
{
   mockitopp::mock_object<interface> mock;
   mock(&interface::func).when(hc(any_of(is("foo"), is("bar")))).thenReturn(true);
   interface& obj = mock.getInstance();

   ASSERT_TRUE(obj.func("foo"));
   ASSERT_TRUE(obj.func("bar"));
   ASSERT_THROW(obj.func("FOO"), mockitopp::detail::IncompleteImplementationException);

}
}}}

=== [http://www.boost.org/doc/libs/1_36_0/libs/regex/doc/html/index.html TR1 <regex>] ===
{{{
#include <regex> // or <boost/regex.hpp>
#include <gtest/gtest.h>
#include <mockitopp/mockitopp.hpp>
#include <mockitopp/matchers/optional/Regex.hpp>

using mockitopp::matcher::regex;

struct interface
{
   virtual bool func(const char*) = 0;
};

TEST(test, regex)
{
   mockitopp::mock_object<interface> mock;
   mock(&interface::func).when(regex("[0-9]*")).thenReturn(true);
   mock(&interface::func).when(regex("he.*ld")).thenReturn(true);
   regex_interface& obj = mock.getInstance();

   ASSERT_TRUE(obj.func("1234567890"));
   ASSERT_TRUE(obj.func("hello world"));
   ASSERT_THROW(obj.func("foo"), mockitopp::detail::IncompleteImplementationException);}
}}}
