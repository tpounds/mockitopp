#labels Featured
== Argument Matching ==
Usually, test cases are required to cover a large permutation of user inputs. This can be troublesome in cases where the system under test has several underlying dependencies. Usually, when using a mock framework to provide the dependencies for the system under test, each dependency will have to stubbed with 1:1 mappings of the user inputs. Overtime this makes test cases quite brittle and becomes a maintenance liability. To help reduce this overhead generic argument matchers are available ({{{<mockitopp/matchers>}}}) to use when stubbing method invocations. These matchers work with all primitive types, but do note that complex types (classes, etc) *must* implement operator==() correctly in order to be used. If your complex types do not implement operator==, you will get a somewhat messy compile error with lots of template expansion to sift through.

=== Built-in ===
{{{
#include <mockitopp/mockitopp.hpp>

using mockitopp::matcher::null;
using mockitopp::matcher::any;
using mockitopp::matcher::equal;
using mockitopp::matcher::is_not;

#include <cassert>
#define ASSERT_TRUE(expr) assert( (expr) == true )
#define ASSERT_FALSE(expr) assert( (expr) == false )
#define ASSERT_THROW(expr, exception) do {                      \
        try {                                                   \
            expr;                                               \
            assert(! #expr " did not throw " #exception);       \
        } catch (exception& ex) {                               \
        } catch (exception* ex) {                               \
        } catch (...) {                                         \
            assert(! #expr " did throw unknown exception");     \
        }                                                       \
    } while(0)

struct interface
{
    virtual bool func1(int*) = 0;
    virtual bool func2(const std::string&) = 0;
    virtual bool func3(int) = 0;
};

int main()
{
    mockitopp::mock_object<interface> mock;

    mock(&interface::func1)
        .when(null<int*>())
        .thenReturn(true);

    mock(&interface::func1)
        .when(any<int*>())
        .thenReturn(false);

    mock(&interface::func2)
        .when(is_not(equal<const std::string&>("foo")))
        .thenReturn(true);

    interface& obj = mock.getInstance();

    int value = 31337;
    ASSERT_TRUE(obj.func1(NULL));
    ASSERT_FALSE(obj.func1(&value));
    ASSERT_TRUE(obj.func2("hello world!"));
    ASSERT_TRUE(obj.func2("bar"));
    ASSERT_THROW(obj.func3(7), mockitopp::missing_implementation_exception);

    return 0;
}
}}}

=== [http://www.boost.org/doc/libs/1_36_0/libs/regex/doc/html/index.html TR1 <regex>] ===
{{{
#include <boost/regex.hpp> // or <regex>
#include <mockitopp/mockitopp.hpp>
#include <mockitopp/matchers/regex.hpp>

using mockitopp::matcher::regex;

#include <cassert>
#define ASSERT_TRUE(expr) assert( (expr) == true )
#define ASSERT_FALSE(expr) assert( (expr) == false )
#define ASSERT_THROW(expr, exception) do {                      \
        try {                                                   \
            expr;                                               \
            assert(! #expr " did not throw " #exception);       \
        } catch (exception& ex) {                               \
        } catch (exception* ex) {                               \
        } catch (...) {                                         \
            assert(! #expr " did throw unknown exception");     \
        }                                                       \
    } while(0)

struct interface
{
    virtual bool func(const char*) = 0;
};

int main()
{
    mockitopp::mock_object<interface> mock;
    mock(&interface::func).when(regex("[0-9]*")).thenReturn(true);
    mock(&interface::func).when(regex("he.*ld")).thenReturn(true);
    interface& obj = mock.getInstance();

    ASSERT_TRUE(obj.func("1234567890"));
    ASSERT_TRUE(obj.func("hello world"));
    ASSERT_THROW(obj.func("foo"), mockitopp::partial_implementation_exception);

    return 0;
}
}}}

GNU g++ versions &lt;= 4.8.1 do not have a fully functional regular expression library. Using the boost regular expression library may be preferred.